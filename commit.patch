diff --git a/.gitignore b/.gitignore
index b1d8932..ba36a14 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,6 @@ myapi.key
 xv6.out*
 .vagrant/
 submissions/
+compile_commands.json
+.gdb_history
+.cache/
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..4024443
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,12 @@
+FROM archlinux:latest
+
+RUN pacman-key --init
+
+RUN pacman -Syu --noconfirm
+
+RUN pacman -S --noconfirm gcc make perl wget git python
+
+RUN pacman -S --noconfirm riscv64-elf-gdb riscv64-elf-gcc riscv64-elf-binutils riscv64-elf-newlib qemu-emulators-full
+
+RUN wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit && \
+    pacman -S --noconfirm python-pygments
diff --git a/Makefile b/Makefile
index cac799d..3932cbe 100644
--- a/Makefile
+++ b/Makefile
@@ -49,6 +49,8 @@ endif
 ifndef TOOLPREFIX
 TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
 	then echo 'riscv64-unknown-elf-'; \
+	elif riscv64-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+	then echo 'riscv64-elf-'; \
 	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
 	then echo 'riscv64-linux-gnu-'; \
 	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
@@ -66,10 +68,11 @@ AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
+GDB = $(TOOLPREFIX)gdb
 
 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DTEST
 
-GCC_VER12 := $(shell expr `gcc -dumpfullversion -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/'` \>= 120000)
+GCC_VER12 := $(shell expr `$(CC) -dumpfullversion -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/'` \>= 120000)
 ifeq "$(GCC_VER12)" "1"
 CFLAGS += -Wno-error=infinite-recursion
 endif
@@ -196,6 +199,25 @@ clean:
         $U/usys.S \
 	$(UPROGS)
 
+
+DOCKER_NAME = xv6-archlinux
+
+build_docker:
+	docker build --network="host" -t ${DOCKER_NAME} .
+
+DOCKER_RUN_ARGS := run
+DOCKER_RUN_ARGS += --rm
+DOCKER_RUN_ARGS += -it
+DOCKER_RUN_ARGS += --privileged
+DOCKER_RUN_ARGS += --network="host"
+DOCKER_RUN_ARGS += -v $(PWD):/mnt
+DOCKER_RUN_ARGS += -w /mnt
+DOCKER_RUN_ARGS += $(DOCKER_NAME)
+DOCKER_RUN_ARGS += bash
+
+docker:
+	docker $(DOCKER_RUN_ARGS)
+
 # try to generate a unique GDB port
 GDBPORT = $(shell expr `id -u` % 5000 + 25000)
 # QEMU's gdb stub command line changed in 0.11
@@ -220,6 +242,16 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
+GDBARGS = 
+GDBARGS += -ex 'set architecture riscv:rv64'
+GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
+GDBARGS += -ex 'symbol-file kernel/kernel'
+GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
+
+
+gdb: 
+	$(GDB) $(GDBARGS)
+
 ##
 ##  FOR testing lab grading script
 ##
diff --git a/commit.patch b/commit.patch
new file mode 100644
index 0000000..833a742
--- /dev/null
+++ b/commit.patch
@@ -0,0 +1,305 @@
+diff --git a/.gitignore b/.gitignore
+index b1d8932..ba36a14 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -20,3 +20,6 @@ myapi.key
+ xv6.out*
+ .vagrant/
+ submissions/
++compile_commands.json
++.gdb_history
++.cache/
+diff --git a/Dockerfile b/Dockerfile
+new file mode 100644
+index 0000000..4024443
+--- /dev/null
++++ b/Dockerfile
+@@ -0,0 +1,12 @@
++FROM archlinux:latest
++
++RUN pacman-key --init
++
++RUN pacman -Syu --noconfirm
++
++RUN pacman -S --noconfirm gcc make perl wget git python
++
++RUN pacman -S --noconfirm riscv64-elf-gdb riscv64-elf-gcc riscv64-elf-binutils riscv64-elf-newlib qemu-emulators-full
++
++RUN wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit && \
++    pacman -S --noconfirm python-pygments
+diff --git a/Makefile b/Makefile
+index cac799d..3932cbe 100644
+--- a/Makefile
++++ b/Makefile
+@@ -49,6 +49,8 @@ endif
+ ifndef TOOLPREFIX
+ TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+ 	then echo 'riscv64-unknown-elf-'; \
++	elif riscv64-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-elf-'; \
+ 	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+ 	then echo 'riscv64-linux-gnu-'; \
+ 	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+@@ -66,10 +68,11 @@ AS = $(TOOLPREFIX)gas
+ LD = $(TOOLPREFIX)ld
+ OBJCOPY = $(TOOLPREFIX)objcopy
+ OBJDUMP = $(TOOLPREFIX)objdump
++GDB = $(TOOLPREFIX)gdb
+ 
+ CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DTEST
+ 
+-GCC_VER12 := $(shell expr `gcc -dumpfullversion -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/'` \>= 120000)
++GCC_VER12 := $(shell expr `$(CC) -dumpfullversion -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/'` \>= 120000)
+ ifeq "$(GCC_VER12)" "1"
+ CFLAGS += -Wno-error=infinite-recursion
+ endif
+@@ -196,6 +199,25 @@ clean:
+         $U/usys.S \
+ 	$(UPROGS)
+ 
++
++DOCKER_NAME = xv6-archlinux
++
++build_docker:
++	docker build --network="host" -t ${DOCKER_NAME} .
++
++DOCKER_RUN_ARGS := run
++DOCKER_RUN_ARGS += --rm
++DOCKER_RUN_ARGS += -it
++DOCKER_RUN_ARGS += --privileged
++DOCKER_RUN_ARGS += --network="host"
++DOCKER_RUN_ARGS += -v $(PWD):/mnt
++DOCKER_RUN_ARGS += -w /mnt
++DOCKER_RUN_ARGS += $(DOCKER_NAME)
++DOCKER_RUN_ARGS += bash
++
++docker:
++	docker $(DOCKER_RUN_ARGS)
++
+ # try to generate a unique GDB port
+ GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+ # QEMU's gdb stub command line changed in 0.11
+@@ -220,6 +242,16 @@ qemu-gdb: $K/kernel .gdbinit fs.img
+ 	@echo "*** Now run 'gdb' in another window." 1>&2
+ 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
+ 
++GDBARGS = 
++GDBARGS += -ex 'set architecture riscv:rv64'
++GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
++GDBARGS += -ex 'symbol-file kernel/kernel'
++GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
++
++
++gdb: 
++	$(GDB) $(GDBARGS)
++
+ ##
+ ##  FOR testing lab grading script
+ ##
+diff --git a/grade-lab-util b/grade-lab-util
+index 3df25bf..5f5446a 100755
+--- a/grade-lab-util
++++ b/grade-lab-util
+@@ -28,15 +28,75 @@ def test_sleep():
+     ]), stop_breakpoint('sys_sleep'))
+     r.match('\\$ sleep 10', no=['FAIL'])
+ 
+-@test(20, "pingpong")
++@test(10, "pingpong lenient testing")
+ def test_pingpong():
+     r.run_qemu(shell_script([
+         'pingpong', 'echo OK'
+     ]))
+-    r.match('^\\d+: received ping$', '^\\d+: received pong$', '^OK$')
++    r.match('^\\d+: received ping from pid \\d+$', '^\\d+: received pong from pid \\d+$', '^OK$')
+ 
+-@test(10, "find, in current directory")
+-def test_find_curdir():
++@test(10, "pingpong strict testing with changing pids")
++def test_pingpong_strict_pid_change():
++    def strict_match(line):
++        """Regular expression to match ping/pong lines and capture process IDs"""
++        match_ping = re.match(r'^(\d+): received ping from pid (\d+)$', line)
++        match_pong = re.match(r'^(\d+): received pong from pid (\d+)$', line)
++        
++        if match_ping:
++            pid1, pid2 = match_ping.groups()
++            return (int(pid1), int(pid2))  # Return the captured process IDs
++            
++        elif match_pong:
++            pid1, pid2 = match_pong.groups()
++            return (int(pid1), int(pid2))  # Return the captured process IDs
++        
++        return None
++
++    # Run QEMU and execute pingpong three times
++    r.run_qemu(shell_script([
++        'pingpong', 'pingpong', 'pingpong', 'echo OK'
++    ]))
++
++    # Clean the output, remove ANSI color codes, and filter valid lines
++    clean_lines = []
++    for line in r.qemu.output.splitlines():
++        line = re.sub(r'\x1b\[[0-9;]*m', '', line)  # Remove color codes
++        if re.match(r'^\d+: received (ping|pong) from pid \d+$', line) or re.match(r'^OK$', line):
++            clean_lines.append(line)
++
++    # Initialize variables to store previous process IDs
++    prev_ping_pid = None
++    prev_pong_pid = None
++
++    # Iterate through each run, two lines per run
++    for i in range(0, len(clean_lines) - 2, 2):
++        # Get the ping and pong lines
++        ping_match = strict_match(clean_lines[i])
++        pong_match = strict_match(clean_lines[i+1])
++
++        # Check if the format matches
++        assert ping_match and pong_match, "Ping/Pong output format mismatch"
++        
++        # Get the process IDs for the current run
++        ping_pid, pong_pid = ping_match[0], ping_match[1]
++
++        # Check if the process IDs match
++        assert ping_pid == pong_match[1], f"PID mismatch: {ping_pid} != {pong_match[1]}"
++        assert pong_pid == pong_match[0], f"PID mismatch: {pong_pid} != {pong_match[0]}"
++
++        # Check if the process IDs are different from the previous run
++        if prev_ping_pid is not None and prev_pong_pid is not None:
++            assert ping_pid != prev_ping_pid and pong_pid != prev_pong_pid, \
++                "Process IDs did not change between runs"
++
++        # Store the current process IDs for comparison in the next run
++        prev_ping_pid, prev_pong_pid = ping_pid, pong_pid
++
++    # Finally, match the echo OK output
++    assert clean_lines[-1] == 'OK', "Final OK message missing"
++
++@test(5, "find, in current directory and create a file")
++def test_find_file_curdir():
+     fn = random_str()
+     r.run_qemu(shell_script([
+         'echo > %s' % fn,
+@@ -44,8 +104,17 @@ def test_find_curdir():
+     ]))
+     r.match('./%s' % fn)
+ 
+-@test(10, "find, recursive")
+-def test_find_recursive():
++@test(5, "find, in current directory and create a dir")
++def test_find_dir_curdir():
++    fn = random_str()
++    r.run_qemu(shell_script([
++        'mkdir %s' % fn,
++        'find . %s' % fn
++    ]))
++    r.match('./%s' % fn)
++
++@test(5, "find, find file recursive")
++def test_find_file_recursive():
+     needle = random_str()
+     dirs = [random_str() for _ in range(3)]
+     r.run_qemu(shell_script([
+@@ -60,5 +129,43 @@ def test_find_recursive():
+     r.match('./%s/%s' % (dirs[0], needle),
+             './%s/%s/%s' % (dirs[0], dirs[1], needle),
+             './%s/%s' % (dirs[2], needle))
++    
++@test(5, "find, find dir recursive with no duplicates")
++def test_find_recursive_no_duplicates():
++    needle = random_str()
++    dirs = [random_str() for _ in range(3)]
++    
++    r.run_qemu(shell_script([
++        'mkdir %s' % dirs[0],
++        'echo > %s/%s' % (dirs[0], needle),
++        'mkdir %s/%s' % (dirs[0], dirs[1]),
++        'mkdir %s/%s/%s' % (dirs[0], dirs[1], needle),
++        'mkdir %s' % dirs[2],
++        'echo > %s/%s' % (dirs[2], needle),
++        'find . %s' % needle
++    ]))
++
++    expected_lines = [
++        './%s/%s' % (dirs[0], needle),
++        './%s/%s/%s' % (dirs[0], dirs[1], needle),
++        './%s/%s' % (dirs[2], needle)
++    ]
++
++    output_lines = r.qemu.output.splitlines()
++
++    clean_lines = []
++    for line in output_lines:
++        line = re.sub(r'\x1b\[[0-9;]*m', '', line)  
++        if re.match(r'^\./.*$', line):  
++            clean_lines.append(line)
++
++    unique_clean_lines = list(set(clean_lines))
++
++    for expected in expected_lines:
++        assert expected in unique_clean_lines, "Expected path '%s' not found in output" % expected
++
++    assert len(clean_lines) == len(expected_lines), \
++        "Expected %d unique lines, but found %d" % (len(expected_lines), len(unique_clean_lines))
++
+ 
+ run_tests()
+diff --git a/user/ulib.c b/user/ulib.c
+index 27c0e8c..9d1281b 100644
+--- a/user/ulib.c
++++ b/user/ulib.c
+@@ -65,6 +65,7 @@ int stat(const char *n, struct stat *st) {
+   return r;
+ }
+ 
++// convert string to integer
+ int atoi(const char *s) {
+   int n;
+ 
+@@ -73,6 +74,35 @@ int atoi(const char *s) {
+   return n;
+ }
+ 
++// convert integer to string
++void itoa(int n, char s[]) {
++    int i = 0;
++    int is_negative = 0;
++
++    if (n < 0) {
++        is_negative = 1;
++        n = -n;
++    }
++
++    do {
++        s[i++] = n % 10 + '0';
++        n /= 10;
++    } while (n > 0);
++
++    if (is_negative) {
++        s[i++] = '-';
++    }
++
++    s[i] = '\0';
++
++    // invert string
++    for (int j = 0; j < i / 2; j++) {
++        char temp = s[j];
++        s[j] = s[i - j - 1];
++        s[i - j - 1] = temp;
++    }
++}
++
+ void *memmove(void *vdst, const void *vsrc, int n) {
+   char *dst;
+   const char *src;
+diff --git a/user/user.h b/user/user.h
+index b71ecda..739d534 100644
+--- a/user/user.h
++++ b/user/user.h
+@@ -38,5 +38,6 @@ void* memset(void*, int, uint);
+ void* malloc(uint);
+ void free(void*);
+ int atoi(const char*);
++void itoa(int n, char s[]);
+ int memcmp(const void *, const void *, uint);
+ void *memcpy(void *, const void *, uint);
diff --git a/foo.txt b/foo.txt
new file mode 100644
index 0000000..e69de29
diff --git a/grade-lab-util b/grade-lab-util
index 3df25bf..5f5446a 100755
--- a/grade-lab-util
+++ b/grade-lab-util
@@ -28,15 +28,75 @@ def test_sleep():
     ]), stop_breakpoint('sys_sleep'))
     r.match('\\$ sleep 10', no=['FAIL'])
 
-@test(20, "pingpong")
+@test(10, "pingpong lenient testing")
 def test_pingpong():
     r.run_qemu(shell_script([
         'pingpong', 'echo OK'
     ]))
-    r.match('^\\d+: received ping$', '^\\d+: received pong$', '^OK$')
+    r.match('^\\d+: received ping from pid \\d+$', '^\\d+: received pong from pid \\d+$', '^OK$')
 
-@test(10, "find, in current directory")
-def test_find_curdir():
+@test(10, "pingpong strict testing with changing pids")
+def test_pingpong_strict_pid_change():
+    def strict_match(line):
+        """Regular expression to match ping/pong lines and capture process IDs"""
+        match_ping = re.match(r'^(\d+): received ping from pid (\d+)$', line)
+        match_pong = re.match(r'^(\d+): received pong from pid (\d+)$', line)
+        
+        if match_ping:
+            pid1, pid2 = match_ping.groups()
+            return (int(pid1), int(pid2))  # Return the captured process IDs
+            
+        elif match_pong:
+            pid1, pid2 = match_pong.groups()
+            return (int(pid1), int(pid2))  # Return the captured process IDs
+        
+        return None
+
+    # Run QEMU and execute pingpong three times
+    r.run_qemu(shell_script([
+        'pingpong', 'pingpong', 'pingpong', 'echo OK'
+    ]))
+
+    # Clean the output, remove ANSI color codes, and filter valid lines
+    clean_lines = []
+    for line in r.qemu.output.splitlines():
+        line = re.sub(r'\x1b\[[0-9;]*m', '', line)  # Remove color codes
+        if re.match(r'^\d+: received (ping|pong) from pid \d+$', line) or re.match(r'^OK$', line):
+            clean_lines.append(line)
+
+    # Initialize variables to store previous process IDs
+    prev_ping_pid = None
+    prev_pong_pid = None
+
+    # Iterate through each run, two lines per run
+    for i in range(0, len(clean_lines) - 2, 2):
+        # Get the ping and pong lines
+        ping_match = strict_match(clean_lines[i])
+        pong_match = strict_match(clean_lines[i+1])
+
+        # Check if the format matches
+        assert ping_match and pong_match, "Ping/Pong output format mismatch"
+        
+        # Get the process IDs for the current run
+        ping_pid, pong_pid = ping_match[0], ping_match[1]
+
+        # Check if the process IDs match
+        assert ping_pid == pong_match[1], f"PID mismatch: {ping_pid} != {pong_match[1]}"
+        assert pong_pid == pong_match[0], f"PID mismatch: {pong_pid} != {pong_match[0]}"
+
+        # Check if the process IDs are different from the previous run
+        if prev_ping_pid is not None and prev_pong_pid is not None:
+            assert ping_pid != prev_ping_pid and pong_pid != prev_pong_pid, \
+                "Process IDs did not change between runs"
+
+        # Store the current process IDs for comparison in the next run
+        prev_ping_pid, prev_pong_pid = ping_pid, pong_pid
+
+    # Finally, match the echo OK output
+    assert clean_lines[-1] == 'OK', "Final OK message missing"
+
+@test(5, "find, in current directory and create a file")
+def test_find_file_curdir():
     fn = random_str()
     r.run_qemu(shell_script([
         'echo > %s' % fn,
@@ -44,8 +104,17 @@ def test_find_curdir():
     ]))
     r.match('./%s' % fn)
 
-@test(10, "find, recursive")
-def test_find_recursive():
+@test(5, "find, in current directory and create a dir")
+def test_find_dir_curdir():
+    fn = random_str()
+    r.run_qemu(shell_script([
+        'mkdir %s' % fn,
+        'find . %s' % fn
+    ]))
+    r.match('./%s' % fn)
+
+@test(5, "find, find file recursive")
+def test_find_file_recursive():
     needle = random_str()
     dirs = [random_str() for _ in range(3)]
     r.run_qemu(shell_script([
@@ -60,5 +129,43 @@ def test_find_recursive():
     r.match('./%s/%s' % (dirs[0], needle),
             './%s/%s/%s' % (dirs[0], dirs[1], needle),
             './%s/%s' % (dirs[2], needle))
+    
+@test(5, "find, find dir recursive with no duplicates")
+def test_find_recursive_no_duplicates():
+    needle = random_str()
+    dirs = [random_str() for _ in range(3)]
+    
+    r.run_qemu(shell_script([
+        'mkdir %s' % dirs[0],
+        'echo > %s/%s' % (dirs[0], needle),
+        'mkdir %s/%s' % (dirs[0], dirs[1]),
+        'mkdir %s/%s/%s' % (dirs[0], dirs[1], needle),
+        'mkdir %s' % dirs[2],
+        'echo > %s/%s' % (dirs[2], needle),
+        'find . %s' % needle
+    ]))
+
+    expected_lines = [
+        './%s/%s' % (dirs[0], needle),
+        './%s/%s/%s' % (dirs[0], dirs[1], needle),
+        './%s/%s' % (dirs[2], needle)
+    ]
+
+    output_lines = r.qemu.output.splitlines()
+
+    clean_lines = []
+    for line in output_lines:
+        line = re.sub(r'\x1b\[[0-9;]*m', '', line)  
+        if re.match(r'^\./.*$', line):  
+            clean_lines.append(line)
+
+    unique_clean_lines = list(set(clean_lines))
+
+    for expected in expected_lines:
+        assert expected in unique_clean_lines, "Expected path '%s' not found in output" % expected
+
+    assert len(clean_lines) == len(expected_lines), \
+        "Expected %d unique lines, but found %d" % (len(expected_lines), len(unique_clean_lines))
+
 
 run_tests()
diff --git a/user/ulib.c b/user/ulib.c
index 27c0e8c..9d1281b 100644
--- a/user/ulib.c
+++ b/user/ulib.c
@@ -65,6 +65,7 @@ int stat(const char *n, struct stat *st) {
   return r;
 }
 
+// convert string to integer
 int atoi(const char *s) {
   int n;
 
@@ -73,6 +74,35 @@ int atoi(const char *s) {
   return n;
 }
 
+// convert integer to string
+void itoa(int n, char s[]) {
+    int i = 0;
+    int is_negative = 0;
+
+    if (n < 0) {
+        is_negative = 1;
+        n = -n;
+    }
+
+    do {
+        s[i++] = n % 10 + '0';
+        n /= 10;
+    } while (n > 0);
+
+    if (is_negative) {
+        s[i++] = '-';
+    }
+
+    s[i] = '\0';
+
+    // invert string
+    for (int j = 0; j < i / 2; j++) {
+        char temp = s[j];
+        s[j] = s[i - j - 1];
+        s[i - j - 1] = temp;
+    }
+}
+
 void *memmove(void *vdst, const void *vsrc, int n) {
   char *dst;
   const char *src;
diff --git a/user/user.h b/user/user.h
index b71ecda..739d534 100644
--- a/user/user.h
+++ b/user/user.h
@@ -38,5 +38,6 @@ void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+void itoa(int n, char s[]);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
