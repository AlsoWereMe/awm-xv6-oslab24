diff --git a/Makefile b/Makefile
index 984fbc7..51fc5ff 100644
--- a/Makefile
+++ b/Makefile
@@ -146,6 +146,7 @@ mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
 .PRECIOUS: %.o
 
 UPROGS=\
+	$U/_stat\
 	$U/_cat\
 	$U/_echo\
 	$U/_forktest\
diff --git a/commit.patch b/commit.patch
new file mode 100644
index 0000000..e69de29
diff --git a/kernel/defs.h b/kernel/defs.h
index 4749759..cbbe6e0 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -117,6 +117,7 @@ int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
 uint64          get_unused_procs(void);
 int             wait_sched(int *runable_time, int *running_time, int *sleep_time);
+int             on_stage_change(int cur_state, int nxt_state, struct proc *p);
 int             set_priority(int, int);
 
 // swtch.S
diff --git a/kernel/proc.c b/kernel/proc.c
index 2046a20..4d8b37b 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -99,8 +99,30 @@ static struct proc *allocproc(void) {
 
 found:
   p->pid = allocpid();
+
+  p->state = UNUSED;            // 初始化进程状态为 UNUSED
+  p->parent = 0;                // 初始化父进程指针为NULL,即0
+  p->chan = 0;                  // 初始化通道
+  p->killed = 0;                // 初始化 killed 状态
+  p->xstate = 0;                // 初始化退出状态
+  p->kstack = (uint64)kalloc(); 
   
-  // TODO: add A LOT OF init here
+  // 初始化私有进程信息
+  p->sz = 0;                             // 进程内存大小初始化
+  p->pagetable = 0;                      // 页表指针初始化
+  p->trapframe = 0;                      // 陷阱帧初始化
+  memset(p->ofile, 0, sizeof(p->ofile)); // 清空文件描述符数组
+  p->cwd = 0;                            // 当前目录初始化
+  memset(p->name, 0, sizeof(p->name));   // 清空进程名称
+
+  // 初始化时间相关信息
+  p->created_time = ticks;         
+  p->finish_time = 0;          
+  p->running_time = 0;         
+  p->runable_time = 0;         
+  p->sleep_time = 0;           
+  p->start = ticks;                
+  p->end = 0;   
 
   #ifdef PR
   p->priority = 2;
@@ -210,6 +232,7 @@ void userinit(void) {
   p->cwd = namei("/");
 
   // TODO: on state change
+  on_state_change(p->state, RUNNABLE, p);
   p->state = RUNNABLE;
 
   release(&p->lock);
@@ -271,6 +294,7 @@ int fork(void) {
   pid = np->pid;
 
   // TODO: on state change
+  on_state_change(np->state, RUNNABLE, np);
   np->state = RUNNABLE;
 
   release(&np->lock);
@@ -356,8 +380,8 @@ void exit(int status) {
   wakeup1(original_parent);
 
   // TODO: on state change
-
   p->xstate = status;
+  on_state_change(p->state, ZOMBIE, p);
   p->state = ZOMBIE;
 
   release(&original_parent->lock);
@@ -454,19 +478,48 @@ void scheduler(void) {
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
-
         found = 1;
       }
       release(&p->lock);
     }
     #elif defined PR
-    // Priority scheduling, iterating over max_p to find process with highest priority
+        struct proc *p_high = 0; // 用于记录最高优先级的进程
+        int highest_priority = 4; // 初始化为最低优先级+1
+
+        for (struct proc *p_iter = proc; p_iter < &proc[NPROC]; p_iter++) {
+            acquire(&p_iter->lock);
+            if (p_iter->state == RUNNABLE) {
+                if (p_iter->priority < highest_priority) {
+                    if (p_high != 0) {
+                        release(&p_high->lock);
+                    }
+                    highest_priority = p_iter->priority;
+                    p_high = p_iter;
+                } else {
+                    release(&p_iter->lock);
+                }
+            } else {
+                release(&p_iter->lock);
+            }
+        }
 
-    // First find the process with the highest priority and is RUNNABLE
-    
-    
-    // If found such max_p, copy to p, and run it.
-    
+        if (p_high != 0) {
+            // 找到了最高优先级的进程，进行调度
+            p = p_high;
+
+            // 进行状态转换
+            on_state_change(p->state, RUNNING, p);
+            p->state = RUNNING;
+            c->proc = p;
+
+            swtch(&c->context, &p->context);
+
+            // 进程运行完毕
+            c->proc = 0;
+            found = 1;
+
+            release(&p->lock);
+        }
     #endif
     // The same as Round-Robin, if no RUNNABLE process is found, we will wait for interrupt
     if (found == 0) {
@@ -503,7 +556,7 @@ void yield(void) {
   acquire(&p->lock);
 
   // TODO: on state change
-  
+  on_state_change(p->state, RUNNABLE, p);
   p->state = RUNNABLE;
   sched();
   release(&p->lock);
@@ -545,7 +598,7 @@ void sleep(void *chan, struct spinlock *lk) {
   }
 
   // TODO: on state change
-
+  on_state_change(p->state, SLEEPING, p);
   // Go to sleep.
   p->chan = chan;
   p->state = SLEEPING;
@@ -571,7 +624,7 @@ void wakeup(void *chan) {
     acquire(&p->lock);
     if (p->state == SLEEPING && p->chan == chan) {
       // TODO: on state change
-
+      on_state_change(p->state, RUNNABLE, p);
       p->state = RUNNABLE;
     }
     release(&p->lock);
@@ -583,6 +636,7 @@ void wakeup(void *chan) {
 static void wakeup1(struct proc *p) {
   if (!holding(&p->lock)) panic("wakeup1");
   if (p->chan == p && p->state == SLEEPING) {
+    on_state_change(p->state, RUNNABLE, p);
     p->state = RUNNABLE;
   }
 }
@@ -597,12 +651,11 @@ int kill(int pid) {
     acquire(&p->lock);
     if (p->pid == pid) {
       p->killed = 1;
-      if (p->state == SLEEPING) {
-        // TODO: on state change
-
-        // Wake process from sleep().
+    // TODO: on state change
+    if (p->state == SLEEPING) {
+        on_state_change(p->state, RUNNABLE, p);
         p->state = RUNNABLE;
-      }
+    }
       release(&p->lock);
       return 0;
     }
@@ -673,16 +726,92 @@ uint64 get_unused_procs(void) {
 
 // get the running time, sleeping time, runnable time when the child process returns 
 int wait_sched(int *runable_time, int *running_time, int *sleep_time) {
+  struct proc *p = myproc();
+  struct proc *np;
+  int havekids, pid;
+
+  acquire(&p->lock);
+
+  for (;;) {
+    havekids = 0;
+    for (np = proc; np < &proc[NPROC]; np++) {
+      if (np->parent == p) {
+        havekids = 1;
+        acquire(&np->lock);
+        if (np->state == ZOMBIE) {
+          pid = np->pid;
 
+          // Copy the statistics from the child to the parent
+          if (copyout(p->pagetable, (uint64)runable_time, (char *)&np->runable_time, sizeof(int)) < 0 ||
+              copyout(p->pagetable, (uint64)running_time, (char *)&np->running_time, sizeof(int)) < 0 ||
+              copyout(p->pagetable, (uint64)sleep_time, (char *)&np->sleep_time, sizeof(int)) < 0) {
+            release(&np->lock);
+            release(&p->lock);
+            return -1;
+          }
+
+          freeproc(np);
+          release(&np->lock);
+          release(&p->lock);
+          return pid;
+        }
+        release(&np->lock);
+      }
+    }
+    if (!havekids || p->killed) {
+      release(&p->lock);
+      return -1;
+    }
+
+    sleep(p, &p->lock);
+  }
 }
 
+
+
 // UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE
 int on_state_change(int cur_state, int nxt_state, struct proc *p) {
-    
+    p->end = ticks;
+    switch (cur_state) {
+    case UNUSED:
+        p->runable_time = 0;
+        break;
+    case SLEEPING:
+        p->sleep_time += p->end - p->start;
+        break;
+    case RUNNABLE:
+        p->runable_time += p->end - p->start;
+        break;
+    case RUNNING:
+        p->running_time += p->end - p->start;
+        break;
+    case ZOMBIE:
+        p->created_time = p->end;
+        break;
+    default:
+        return -1;
+    }
+    p->start = p->end;
+    return 0;
 }
 
+
 // set priority [0-3] to a given process [pid]
 // -1 means error, 0 means success
 int set_priority(int priority, int pid) {
-    
+    if (priority < 0 || priority > 3) {
+        return -1;
+    }
+    struct proc *p;
+    for (p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        if (p->pid == pid) {
+            p->priority = priority;
+            release(&p->lock);
+            return 0; // 设置成功
+        }
+        release(&p->lock);
+    }
+    return -1;
 }
+
diff --git a/kernel/syscall.c b/kernel/syscall.c
index dc65099..aefa9e7 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -93,6 +93,8 @@ extern uint64 sys_uptime(void);
 extern uint64 sys_rename(void);
 extern uint64 sys_trace(void);
 extern uint64 sys_sysinfo(void);
+extern uint64 sys_wait_sched(void);
+extern uint64 sys_set_priority(void);
 
 static uint64 (*syscalls[])(void) = {
     [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,     [SYS_pipe] sys_pipe,
@@ -101,6 +103,7 @@ static uint64 (*syscalls[])(void) = {
     [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,     [SYS_write] sys_write,
     [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link,     [SYS_mkdir] sys_mkdir,
     [SYS_close] sys_close, [SYS_rename] sys_rename, [SYS_trace] sys_trace,   [SYS_sysinfo] sys_sysinfo,
+    [SYS_wait_sched] sys_wait_sched, [SYS_set_priority] sys_set_priority
 };
 
 char *syscallnames[] = {
@@ -128,6 +131,8 @@ char *syscallnames[] = {
   [SYS_rename]  "rename",
   [SYS_trace]   "trace",
   [SYS_sysinfo] "sysinfo",
+  [SYS_wait_sched] "wait_sched",
+  [SYS_set_priority] "set_priority"
 };
 
 void syscall(void) {
diff --git a/kernel/syscall.h b/kernel/syscall.h
index 09c9fe5..2d2e379 100755
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -22,4 +22,6 @@
 #define SYS_close  21
 #define SYS_rename 22
 #define SYS_trace 23
-#define SYS_sysinfo 24
\ No newline at end of file
+#define SYS_sysinfo 24
+#define SYS_wait_sched 25
+#define SYS_set_priority 26
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index b60e60c..a4ebe95 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -116,11 +116,25 @@ uint64 sys_sysinfo(void) {
 
 // 统计进程调度信息的系统调用
 uint64 sys_wait_sched(void) {
-    
+    uint64 runable_time, running_time, sleep_time;
+
+    if (argaddr(0, &runable_time) < 0 ||
+        argaddr(1, &running_time) < 0 ||
+        argaddr(2, &sleep_time) < 0) {
+        return -1;
+    }
+
+    return wait_sched((int *)runable_time, (int *)running_time, (int *)sleep_time);
 }
 
 
+
 // 设置进程优先级的系统调用
 uint64 sys_set_priority(void) {
-    
-}
\ No newline at end of file
+    int priority;
+    int pid;
+    if (argint(0, &priority) < 0 || argint(1, &pid) < 0) {
+        return -1;
+    }
+    return set_priority(priority, pid);
+}
diff --git a/user/stat.c b/user/stat.c
index ff6cde0..7d136ad 100644
--- a/user/stat.c
+++ b/user/stat.c
@@ -72,7 +72,6 @@ int main(int argc, char *argv[]) {
 
         //  wait_sched(int *runable_time, int *running_time, int *sleep_time);
         int pid = wait_sched(&runable_time, &running_time, &sleep_time);  // 调用wait_sched获取统计信息
-
         if (pid >= 0) {
             printf("PID: %d | Runnable Time: %d ticks | Running Time: %d ticks | Sleep Time: %d ticks\n",
                    pid, runable_time, running_time, sleep_time);
diff --git a/user/usys.pl b/user/usys.pl
index 1c0311e..b0ceff2 100644
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -14,7 +14,7 @@ sub entry {
     print " ecall\n";
     print " ret\n";
 }
-	
+
 entry("fork");
 entry("exit");
 entry("wait");
